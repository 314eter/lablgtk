Index: utils/config.mlp
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/utils/config.mlp,v
retrieving revision 1.16
retrieving revision 1.26
diff -c -r1.16 -r1.26
*** config.mlp	1999/03/08 08:34:21	1.16
--- config.mlp	1999/06/22 05:46:50	1.26
***************
*** 11,17 ****
  
  (* $Id$ *)
  
! let version = "2.02 with Kyoto labels and variants"
  
  let standard_library =
    try
--- 11,17 ----
  
  (* $Id$ *)
  
! let version = "2.02 with Kyoto extensions (99/06/22)"
  
  let standard_library =
    try
Index: typing/btype.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/btype.ml,v
retrieving revision 1.13
retrieving revision 1.14
diff -c -r1.13 -r1.14
*** btype.ml	1999/01/19 10:37:18	1.13
--- btype.ml	1999/03/30 09:58:42	1.14
***************
*** 47,91 ****
      Fvar {contents = Some kind} -> field_kind_repr kind
    | kind                        -> kind
  
! let rec repr =
!   function
!     {desc = Tlink t'} ->
        (* 
           We do no path compression. Path compression does not seem to
           improve notably efficiency, and it prevents from changing a
           [Tlink] into another type (for instance, for undoing a
           unification).
        *)
! 	repr t'
!     | {desc = Tfield (_, k, _, t')} when field_kind_repr k = Fabsent ->
! 	repr t'
!     | {desc = Tvariant ({var_ext = {desc = Tlink _|Tvariant _}} as var)}
!       as t ->
! 	(* Too big to do it here ? Fast enough *)
! 	let var' = last_variant var in
! 	if var' == var then t else
! 	let var =
! 	  { var_max =
! 	      List.map
! 	        (fun (lab, t) ->
! 		  lab, try List.assoc lab var.var_max with Not_found -> t)
! 	         var'.var_max;
! 	      var_min = var'.var_min;
! 	    var_closed = var'.var_closed;
! 	    var_ext = var'.var_ext;
! 	    var_name =
! 	      if var.var_name <> None & var.var_closed &
! 		List.length var.var_max = List.length var'.var_max
! 	      then var.var_name else var'.var_name }
! 	in
! 	(* Here path compression is needed :-( *)
! 	t.desc <- Tvariant var; t
!     | t -> t
! 
! and last_variant var =
!   match repr var.var_ext with
!     {desc=Tvariant var} -> last_variant var
!   | _ -> var
  
  
                    (**********************************)
--- 47,87 ----
      Fvar {contents = Some kind} -> field_kind_repr kind
    | kind                        -> kind
  
! let rec repr t =
!   match t.desc with
!     Tlink t' ->
        (* 
           We do no path compression. Path compression does not seem to
           improve notably efficiency, and it prevents from changing a
           [Tlink] into another type (for instance, for undoing a
           unification).
        *)
!       repr t'
!   | Tfield (_, k, _, t') when field_kind_repr k = Fabsent ->
!       repr t'
!   | Tvariant var ->
!       (* Too big to do it here ? Fast enough *)
!       let ext = repr var.var_ext in
!       begin match ext.desc with
! 	Tvariant var' ->
! 	  if var' == var then t else
! 	  let var =
! 	    { var' with
! 	      var_max =
! 	        List.map
! 		  (fun (lab, t) ->
! 		    lab, try List.assoc lab var.var_max with Not_found -> t)
! 		  var'.var_max;
! 	      var_name =
! 	        if var.var_name <> None & var.var_closed &
! 		  List.length var.var_max = List.length var'.var_max
! 		then var.var_name else var'.var_name }
! 	  in
!           (* Here path compression is needed :-( *)
! 	  t.desc <- Tvariant var; t
!       |	_ -> t
!       end
!   | _ -> t
  
  
                    (**********************************)
Index: typing/ctype.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/ctype.ml,v
retrieving revision 1.51
retrieving revision 1.64
diff -c -r1.51 -r1.64
*** ctype.ml	1999/03/08 07:49:10	1.51
--- ctype.ml	1999/06/11 01:46:34	1.64
***************
*** 166,171 ****
--- 166,179 ----
      let hash (t, t') = t.id + 93 * t'.id
   end)
  
+ (* A module for hash-tables indexed on types *)
+ 
+ module HType = Hashtbl.Make (struct
+   type t = type_expr
+   let equal = (==)
+   let hash t = t.id
+ end)
+ 
                    (**********************************************)
                    (*  Miscellaneous operations on object types  *)
                    (**********************************************)
***************
*** 248,253 ****
--- 256,267 ----
      Tobject (fi, _) -> find fi
    | _               -> assert false
  
+ let rec row_level f =
+   match repr f with
+     { desc = Tvar ; level = l } -> l
+   | { desc = Tfield (_,_,_,f) } -> row_level f
+   | _                           -> assert false
+ 
  (**** Object name manipulation ****)
  (* +++ Bientot obsolete *)
  
***************
*** 509,514 ****
--- 523,546 ----
      iter_type_expr generalize_structure ty
    end
  
+ (* Generalize the structure and lower the variables *)
+ 
+ let rec generalize_expansive ty =
+   let ty = repr ty in
+   if ty.level <> generic_level then begin
+     if ty.desc = Tvar && ty.level > !nongen_level then
+       ty.level <- !nongen_level
+     else if ty.level > !current_level then begin
+       ty.level <- generic_level;
+       begin match ty.desc with
+ 	Tconstr (_, _, abbrev) ->
+           iter_abbrev generalize_expansive !abbrev
+       | _ -> ()
+       end;
+       iter_type_expr generalize_expansive ty
+     end
+   end
+ 
  (*
     Lower the levels of a type (assume [level] is not
     [generic_level]).
***************
*** 534,544 ****
            (* +++ Levels should be restored... *)
            raise (Unify [(ty, newvar2 level)])
          end
!     | Tfield(_, k, _, _) ->
          begin match field_kind_repr k with
            Fvar _ (* {contents = None} *) ->
! 	    (* hideous hack for Didier *)
! 	    if ty.level > level + 1 && ty.level <> generic_level then
  	      raise (Unify [(ty, newvar2 level)])
          | _                              -> ()
          end;
--- 566,577 ----
            (* +++ Levels should be restored... *)
            raise (Unify [(ty, newvar2 level)])
          end
!     | Tfield(_, k, _, f) ->
          begin match field_kind_repr k with
            Fvar _ (* {contents = None} *) ->
! 	    (* Olabl is quite different *)
! 	    let level' = row_level f in
! 	    if level' > level + 1 && level' <> generic_level then
  	      raise (Unify [(ty, newvar2 level)])
          | _                              -> ()
          end;
***************
*** 563,584 ****
    with Unify [_, ty'] ->
      raise (Unify [ty, ty'])
  *)
- (* Change it to allow polytype tagging *)
  
- let make_nongen ty =
-   let rec nongen_rec ty =
-     let ty = repr ty in
-     if ty.level > !nongen_level then begin
-       match ty.desc with
- 	Tvar ->
- 	  ty.level <- pivot_level - !nongen_level
-       |	_ ->
- 	  ty.level <- pivot_level - ty.level;
- 	  iter_type_expr nongen_rec ty
-     end
-   in nongen_rec ty;
-   unmark_type ty
- 
  (* Correct the levels of type [ty]. *)
  let correct_levels ty =
    duplicate_type ty
--- 596,602 ----
***************
*** 654,691 ****
  let abbreviations = ref (ref Mnil)
    (* Abbreviation memorized. *)
  
- let occur_poly env ty =
-   let paths = ref [] in
-   let rec occur_rec ty = 
-     let ty = repr ty in
-     if ty.level >= lowest_level then begin
-       ty.level <- pivot_level - ty.level;
-       match ty.desc with
- 	Tunivar ->
- 	  raise Exit
-       |	Tconstr (p, tl, _) ->
- 	  List.iter occur_rec tl;
- 	  if not (List.mem p !paths) then begin
- 	    paths := p :: !paths;
- 	    try
- 	      let td = Env.find_type p env in
- 	      match td.type_manifest with None -> ()
- 	      | Some t ->
- 		  try occur_rec t; unmark_type t
- 		  with Exit -> unmark_type t; raise Exit
- 	    with Not_found -> ()
- 	  end
-       |	_ -> iter_type_expr occur_rec ty
-     end
-   in
-   try occur_rec ty; unmark_type ty; false
-   with Exit -> unmark_type ty; true
- 
  let all_univars ty =
    let free_uni = ref [] and bound_uni = ref [] in
    let rec occur_rec bound ty =
      let ty = repr ty in
!     if ty.level >= lowest_level then begin
        ty.level <- pivot_level - ty.level;
        match ty.desc with
  	Tunivar ->
--- 672,682 ----
  let abbreviations = ref (ref Mnil)
    (* Abbreviation memorized. *)
  
  let all_univars ty =
    let free_uni = ref [] and bound_uni = ref [] in
    let rec occur_rec bound ty =
      let ty = repr ty in
!     if ty.level = generic_level then begin
        ty.level <- pivot_level - ty.level;
        match ty.desc with
  	Tunivar ->
***************
*** 712,743 ****
    match l1 with [] -> invalid_arg "Ctype.diff_list"
    | a :: l1 -> a :: diff_list l1 l2
  
- let delayed_copy = ref []
-     (* copying to do later *)
  let to_unmark = ref []
  
  (*
     copy0 works in two modes:
  
     1. If share = false then sharing is only kept for variables and cycles.
        Variables are not marked, so this is legal to call free_univars.
-       When a subterm can be unified with sharing, a continuation is
-       stored in delayed_copy for later execution in mode 2.
  
     2. If share = true then all sharing is kept. Variables are marked.
  *)
  
! let rec copy0 env share bound visited ty =
    let ty = repr ty in
    if ty.level <> generic_level then
      ty
-   else if not share & not (occur_poly env ty) then 
-     let t = newvar () in
-     to_unmark := t :: !to_unmark;
-     delayed_copy :=
-       lazy (t.desc <- Tlink (copy0 env true [] visited ty))
-       :: !delayed_copy;
-     t
    else try
      if share & ty.desc <> Tunivar then raise Not_found;
      let t, bound_t = List.assq ty visited in
--- 703,730 ----
    match l1 with [] -> invalid_arg "Ctype.diff_list"
    | a :: l1 -> a :: diff_list l1 l2
  
  let to_unmark = ref []
+ let kind_variables = ref []
+     (* Only used inside class definitions *)
+     (* The following is a hook:
+        there is always a call to cleanup_types later *)
+ let cleanup_types () =
+   kind_variables := [];
+   cleanup_types ()
  
  (*
     copy0 works in two modes:
  
     1. If share = false then sharing is only kept for variables and cycles.
        Variables are not marked, so this is legal to call free_univars.
  
     2. If share = true then all sharing is kept. Variables are marked.
  *)
  
! let rec copy0 share bound visited ty =
    let ty = repr ty in
    if ty.level <> generic_level then
      ty
    else try
      if share & ty.desc <> Tunivar then raise Not_found;
      let t, bound_t = List.assq ty visited in
***************
*** 756,762 ****
  	  (ty,(t,bound)) :: visited
        |	_ -> visited
      in
!     let copy = copy0 env share bound visited in
      let desc = ty.desc in
      if share or desc = Tvar or desc = Tunivar then begin
        save_desc ty desc;
--- 743,749 ----
  	  (ty,(t,bound)) :: visited
        |	_ -> visited
      in
!     let copy = copy0 share bound visited in
      let desc = ty.desc in
      if share or desc = Tvar or desc = Tunivar then begin
        save_desc ty desc;
***************
*** 818,825 ****
            begin match field_kind_repr kind with
              Fpresent ->
                Tfield (label, Fpresent, copy t1, copy t2)
!           | Fvar _ (* {contents = None} *) ->
!               Tfield (label, Fvar (ref None), copy t1, copy t2)
            | Fabsent ->
                assert false
            end
--- 805,821 ----
            begin match field_kind_repr kind with
              Fpresent ->
                Tfield (label, Fpresent, copy t1, copy t2)
!           | Fvar _ as k (* {contents = None} *) ->
! 	      let level = row_level t2 in
! 	      let k =
! 		if level = generic_level or level < lowest_level then
! 		  try List.assq k !kind_variables
! 		  with Not_found ->
! 		    let k' = Fvar (ref None) in
! 		    kind_variables := (k,k') :: !kind_variables;
! 		    k'
! 		else k in
!               Tfield (label, k, copy t1, copy t2)
            | Fabsent ->
                assert false
            end
***************
*** 838,858 ****
  	  let bound = tl @ bound in
  	  let visited =
  	    List.map2 (fun ty t -> ty,(t,bound)) tl tl' @ visited in
! 	  Tpoly (copy0 env share bound visited t1, tl')
        |	Tunivar ->
  	  Tunivar
        end;
      t
    end
  
! let copy = copy0 Env.empty true [] []
! let copy_sep env = copy0 env false [] []
  
! let prepare_copy () =
!   delayed_copy := []; to_unmark := []
  
  let finish_copy () =
-   List.iter Lazy.force !delayed_copy;
    cleanup_types ();
    List.iter unmark_type !to_unmark
  
--- 834,853 ----
  	  let bound = tl @ bound in
  	  let visited =
  	    List.map2 (fun ty t -> ty,(t,bound)) tl tl' @ visited in
! 	  Tpoly (copy0 share bound visited t1, tl')
        |	Tunivar ->
  	  Tunivar
        end;
      t
    end
  
! let copy = copy0 true [] []
! let copy_sep = copy0 false [] []
  
! let prepare_copy env =
!   to_unmark := []
  
  let finish_copy () =
    cleanup_types ();
    List.iter unmark_type !to_unmark
  
***************
*** 867,880 ****
  let instance_poly env univars sch =
    let vars = List.map (fun _ -> newvar ()) univars in
    let pairs = List.map2 (fun u v -> repr u, (v, [])) univars vars in
!   prepare_copy ();
!   let ty = copy0 env false [] pairs sch in
    finish_copy ();
    vars, ty
  
  let instance_sep env sch =
!   prepare_copy ();
!   let ty = copy0 env false [] [] sch in
    finish_copy ();
    ty
  
--- 862,875 ----
  let instance_poly env univars sch =
    let vars = List.map (fun _ -> newvar ()) univars in
    let pairs = List.map2 (fun u v -> repr u, (v, [])) univars vars in
!   prepare_copy env;
!   let ty = copy0 false [] pairs sch in
    finish_copy ();
    vars, ty
  
  let instance_sep env sch =
!   prepare_copy env;
!   let ty = copy_sep sch in
    finish_copy ();
    ty
  
***************
*** 885,900 ****
    tyl
  
  let instance_constructor env cstr =
!   prepare_copy ();
!   let ty_res = (copy_sep env) cstr.cstr_res in
!   let ty_args = List.map (copy_sep env) cstr.cstr_args in
    finish_copy ();
    (ty_args, ty_res)
  
  let instance_label env lbl =
!   prepare_copy ();
!   let ty_res = copy_sep env lbl.lbl_res in
!   let ty_arg = copy_sep env lbl.lbl_arg in
    finish_copy ();
    (ty_arg, ty_res)
  
--- 880,895 ----
    tyl
  
  let instance_constructor env cstr =
!   prepare_copy env;
!   let ty_res = copy_sep cstr.cstr_res in
!   let ty_args = List.map copy_sep cstr.cstr_args in
    finish_copy ();
    (ty_args, ty_res)
  
  let instance_label env lbl =
!   prepare_copy env;
!   let ty_res = copy_sep lbl.lbl_res in
!   let ty_arg = copy_sep lbl.lbl_arg in
    finish_copy ();
    (ty_arg, ty_res)
  
***************
*** 1094,1100 ****
  let rec full_expand env ty =
    let ty = repr (expand_head env ty) in
    match ty.desc with
!     Tobject (fi, {contents = Some (_, v::_)}) when (repr v).desc = Tvar ->
        newty2 ty.level (Tobject (fi, ref None))
    | Tvariant var when var.var_name <> None & is_variable var.var_ext ->
        newty2 ty.level
--- 1089,1095 ----
  let rec full_expand env ty =
    let ty = repr (expand_head env ty) in
    match ty.desc with
!     Tobject (fi, {contents = Some (_, v::_)}) when is_variable v ->
        newty2 ty.level (Tobject (fi, ref None))
    | Tvariant var when var.var_name <> None & is_variable var.var_ext ->
        newty2 ty.level
***************
*** 1128,1157 ****
  (* The marks are already used by [expand_abbrev]... *)
  let visited = ref []
  
! let rec non_recursive_abbrev env ty =
!   let ty = repr ty in
!   if ty == none then raise Recursive_abbrev;
    if not (List.memq ty !visited) then begin
      let level = ty.level in
      visited := ty :: !visited;
      match ty.desc with
        Tconstr(p, args, abbrev) ->
          begin try
!           non_recursive_abbrev env (try_expand_head env ty)
          with Cannot_expand ->
!           iter_type_expr (non_recursive_abbrev env) ty
          end
      | Tobject (_, _) | Tvariant _->
          ()
      | _ ->
!         iter_type_expr (non_recursive_abbrev env) ty
    end
  
  let correct_abbrev env ident params ty =
    visited := [];
!   non_recursive_abbrev env
      (subst env generic_level
!        (ref (Mcons (Path.Pident ident, none, none, Mnil))) None
         [] [] ty);
    visited := []
  
--- 1123,1153 ----
  (* The marks are already used by [expand_abbrev]... *)
  let visited = ref []
  
! let rec non_recursive_abbrev env ty0 ty =
!   let ty0 = repr ty0 and ty = repr ty in
!   if ty == ty0 then raise Recursive_abbrev;
    if not (List.memq ty !visited) then begin
      let level = ty.level in
      visited := ty :: !visited;
      match ty.desc with
        Tconstr(p, args, abbrev) ->
          begin try
!           non_recursive_abbrev env ty0 (try_expand_head env ty)
          with Cannot_expand ->
!           iter_type_expr (non_recursive_abbrev env ty0) ty
          end
      | Tobject (_, _) | Tvariant _->
          ()
      | _ ->
!         iter_type_expr (non_recursive_abbrev env ty0) ty
    end
  
  let correct_abbrev env ident params ty =
    visited := [];
!   let ty0 = newgenvar () in
!   non_recursive_abbrev env ty0
      (subst env generic_level
!        (ref (Mcons (Path.Pident ident, ty0, ty0, Mnil))) None
         [] [] ty);
    visited := []
  
***************
*** 1375,1386 ****
      if ty.level >= lowest_level then begin
        if ty == t0 then raise Occur;
        ty.level <- pivot_level - ty.level;
!       match ty.desc with
! 	Tvariant var ->
! 	  List.iter (function (_,Some t) -> occur_rec t | _ -> ()) var.var_max;
! 	  occur_rec var.var_ext
!       |	_ ->
! 	  iter_type_expr occur_rec ty
      end
    in
    try
--- 1371,1377 ----
      if ty.level >= lowest_level then begin
        if ty == t0 then raise Occur;
        ty.level <- pivot_level - ty.level;
!       iter_type_expr occur_rec ty
      end
    in
    try
***************
*** 1516,1525 ****
    let d1 = t1'.desc and d2 = t2'.desc in
  
    let create_recursion = (t2 != t2') && (deep_occur t1' t2) in
!   let join () =
!     occur env t1' t2;
!     update_level env t1'.level t2;
!     t1'.desc <- Tlink t2
    in
    if !strict then join ();
  
--- 1507,1518 ----
    let d1 = t1'.desc and d2 = t2'.desc in
  
    let create_recursion = (t2 != t2') && (deep_occur t1' t2) in
!   let join =
!     let ty = if t1 == t1' || t1'.desc == Tvar then t2 else t2' in
!     fun () ->
!       occur env t1' ty;
!       update_level env t1'.level ty;
!       t1'.desc <- Tlink ty
    in
    if !strict then join ();
  
***************
*** 1545,1554 ****
  	let var = common_variant var1 var2 in
  	if (repr var1.var_ext).desc = Tunivar then
  	  unify env var1.var_ext var2.var_ext;
- 	let t1' = repr t1' in
- 	let d1' = t1'.desc in
  	let d = Tvariant var in
!        	t1'.desc <- d;
  	let prepare vari =
  	  let ext = repr vari.var_ext in
  	  let dext' = ext.desc in
--- 1538,1547 ----
  	let var = common_variant var1 var2 in
  	if (repr var1.var_ext).desc = Tunivar then
  	  unify env var1.var_ext var2.var_ext;
  	let d = Tvariant var in
! 	let ty = newty2 t1'.level d in
! 	update_level env t2'.level ty;
! 	t2'.desc <- Tlink ty;
  	let prepare vari =
  	  let ext = repr vari.var_ext in
  	  let dext' = ext.desc in
***************
*** 1581,1590 ****
  		try unify_option env (List.assoc lab var2.var_max) ot
  		with Not_found -> ()
  	      end)
! 	    var.var_max;
! 	  t1'.desc <- d1'
  	with Unify trace ->
! 	  t1'.desc <- d1'; undo1 (); undo2 ();
  	  raise (Unify trace)
  	end
      | (Tarrow (p, t1, u1), Tarrow (q, t2, u2))
--- 1574,1582 ----
  		try unify_option env (List.assoc lab var2.var_max) ot
  		with Not_found -> ()
  	      end)
! 	    var.var_max
  	with Unify trace ->
! 	  t2'.desc <- d2; undo1 (); undo2 ();
  	  raise (Unify trace)
  	end
      | (Tarrow (p, t1, u1), Tarrow (q, t2, u2))
***************
*** 1711,1716 ****
--- 1703,1709 ----
  and unify_kind k1 k2 =
    let k1 = field_kind_repr k1 in
    let k2 = field_kind_repr k2 in
+   if k1 == k2 then () else
    match k1, k2 with
      (Fvar r, (Fvar _ | Fpresent))             -> r := Some k2
    | (Fpresent, Fvar r)                        -> r := Some k1
***************
*** 1728,1735 ****
      unify env ty1 ty2
    with Unify trace ->
      raise (Unify (expand_trace env trace))
  
! let _ = unify' := do_strict unify
  
  let free_unify env ty1 ty2 =
    strict := !Clflags.nolabels; univar_pairs := [];
--- 1721,1743 ----
      unify env ty1 ty2
    with Unify trace ->
      raise (Unify (expand_trace env trace))
+ 
+ let unify_var env t1 t2 =
+   let t1 = repr t1 and t2 = repr t2 in
+   if t1 == t2 then () else
+   match t1.desc with
+     Tvar ->
+       begin try
+ 	occur env t1 t2;
+ 	update_level env t1.level t2;
+ 	t1.desc <- Tlink t2
+       with Unify trace ->
+ 	raise (Unify ((t1,t2)::trace))
+       end
+   | _ ->
+       do_strict unify env t1 t2
  
! let _ = unify' := unify_var
  
  let free_unify env ty1 ty2 =
    strict := !Clflags.nolabels; univar_pairs := [];
***************
*** 1746,1765 ****
  (**** Special cases of unification ****)
  
  (* Unify with a variable *)
! let unify_var env t1 t2 =
!   let t1 = repr t1 and t2 = repr t2 in
!   if t1 == t2 then () else
!   match t1.desc with
!     Tvar ->
!       begin try
! 	occur env t1 t2;
! 	update_level env t1.level t2;
! 	t1.desc <- Tlink t2
!       with Unify trace ->
! 	raise (Unify ((t1,t2)::trace))
!       end
!   | _ ->
!       unify env t1 t2
  
  (* Unify [t] and ['a -> 'b]. Return ['a] and ['b]. *)
  let rec filter_arrow env p t =
--- 1754,1762 ----
  (**** Special cases of unification ****)
  
  (* Unify with a variable *)
! let unify_var env ty1 ty2 =
!   strict := true; univar_pairs := [];
!   unify_var env ty1 ty2
  
  (* Unify [t] and ['a -> 'b]. Return ['a] and ['b]. *)
  let rec filter_arrow env p t =
***************
*** 1999,2004 ****
--- 1996,2002 ----
  and moregen_kind k1 k2 =
    let k1 = field_kind_repr k1 in
    let k2 = field_kind_repr k2 in
+   if k1 == k2 then () else
    match k1, k2 with
      (Fvar r, (Fvar _ | Fpresent))  -> r := Some k2
    | (Fpresent, Fpresent)           -> ()
***************
*** 2449,2462 ****
                                (*  Subtyping  *)
                                (***************)
  
- (* A module for hash-tables indexed on types *)
- 
- module HType = Hashtbl.Make (struct
-   type t = type_expr
-   let equal = (==)
-   let hash t = t.id
- end)
- 
  (**** Build a subtype of a given type. ****)
  
  let subtypes = ref (HType.create 1)
--- 2447,2452 ----
***************
*** 2599,2605 ****
  	  then
  	    let (_,cstrs) =
  	      List.fold_left
! 		(fun (rem,subtrace) (c2,ot2) ->
  		  match rem with
  		    (c1, ot1)::rem when c1 = c2 ->
  		      begin match ot1,ot2 with
--- 2589,2595 ----
  	  then
  	    let (_,cstrs) =
  	      List.fold_left
! 		(fun (rem,cstrs) (c2,ot2) ->
  		  match rem with
  		    (c1, ot1)::rem when c1 = c2 ->
  		      begin match ot1,ot2 with
***************
*** 2639,2644 ****
--- 2629,2636 ----
          subtype_rec env ((u1, u2)::trace) u1 u2 cstrs
      | (Ttuple tl1, Ttuple tl2) ->
          subtype_list env trace tl1 tl2 cstrs
+     | (Tconstr(p1, [], _), Tconstr(p2, [], _)) when Path.same p1 p2 ->
+         cstrs
      | (Tconstr(p1, tl1, abbrev1), Tconstr _) when generic_abbrev env p1 ->
          subtype_rec env trace (expand_abbrev env t1) t2 cstrs
      | (Tconstr _, Tconstr(p2, tl2, abbrev2)) when generic_abbrev env p2 ->
***************
*** 2658,2665 ****
  	with
  	  Not_found -> (trace, t1, t2, !univar_pairs) :: cstrs
  	end
-     | (Tconstr(p1, [], _), Tconstr(p2, [], _)) when Path.same p1 p2 ->
-         cstrs
      | (Tconstr _, Tconstr _) ->
          [(trace, t1, t2, !univar_pairs)]
      | (Tconstr(p1, tl1, abbrev1), _) when generic_abbrev env p1 ->
--- 2650,2655 ----
***************
*** 2701,2709 ****
    let (fields1, rest1) = flatten_fields ty1 in
    let (fields2, rest2) = flatten_fields ty2 in
    let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
!   (trace, rest1, build_fields (repr ty2).level miss2 (newvar ()),
!    !univar_pairs)
!     ::
    begin match rest2.desc with
      Tnil   -> []
    | _      ->
--- 2691,2701 ----
    let (fields1, rest1) = flatten_fields ty1 in
    let (fields2, rest2) = flatten_fields ty2 in
    let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
!   begin if miss2 = [] then [] else
!     [trace, rest1, build_fields (repr ty2).level miss2 (newvar ()),
!      !univar_pairs]
!   end
!     @
    begin match rest2.desc with
      Tnil   -> []
    | _      ->
Index: typing/ctype.mli
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/ctype.mli,v
retrieving revision 1.16
retrieving revision 1.17
diff -c -r1.16 -r1.17
*** ctype.mli	1998/12/14 00:02:51	1.16
--- ctype.mli	1999/06/11 01:46:35	1.17
***************
*** 74,83 ****
          (* Generalize in-place the given type *)
  val iterative_generalization: int -> type_expr list -> type_expr list
          (* Efficient repeated generalization of a type *)
  val generalize_structure: type_expr -> unit
          (* Generalize the structure of a type, at same level *)
! val make_nongen: type_expr -> unit
          (* Make non-generalizable the given type *)
  val correct_levels: type_expr -> type_expr
          (* Returns a copy with decreasing levels *)
  val limited_generalize: type_expr -> type_expr -> unit
--- 74,86 ----
          (* Generalize in-place the given type *)
  val iterative_generalization: int -> type_expr list -> type_expr list
          (* Efficient repeated generalization of a type *)
+ val generalize_expansive: type_expr -> unit
+ 	(* Generalize the structure and lower the variables *)
  val generalize_structure: type_expr -> unit
          (* Generalize the structure of a type, at same level *)
! (* val make_nongen: type_expr -> unit *)
          (* Make non-generalizable the given type *)
+         (* Obsolete: use generalize_expansive *)
  val correct_levels: type_expr -> type_expr
          (* Returns a copy with decreasing levels *)
  val limited_generalize: type_expr -> type_expr -> unit
Index: typing/env.mli
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/env.mli,v
retrieving revision 1.1.1.5
retrieving revision 1.2
diff -c -r1.1.1.5 -r1.2
*** env.mli	1998/08/20 01:31:02	1.1.1.5
--- env.mli	1999/06/22 05:46:50	1.2
***************
*** 121,123 ****
--- 121,128 ----
  (* Forward declaration to break mutual recursion with includemod. *)
  
  val check_modtype_inclusion: (t -> module_type -> module_type -> unit) ref
+ 
+ (* Private export: use with care *)
+ 
+ val labels_of_type:
+     Path.t -> type_declaration -> (string * label_description) list
Index: typing/printtyp.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/printtyp.ml,v
retrieving revision 1.35
retrieving revision 1.37
diff -c -r1.35 -r1.37
*** printtyp.ml	1999/03/08 07:49:11	1.35
--- printtyp.ml	1999/06/01 13:51:31	1.37
***************
*** 181,195 ****
  	mark_loops_rec visited ty
      | Tunivar             -> ()
  
! let mark_loops ty = mark_loops_rec [] ty
  
  let reset_loop_marks () =
    visited_objects := []; aliased := []
  
  let delayed = ref []
  
  let reset () =
!   reset_names (); reset_loop_marks (); delayed := []
  
  let rec print_sep_list pr sep = function
      [] -> ()
--- 181,197 ----
  	mark_loops_rec visited ty
      | Tunivar             -> ()
  
! let already_visited = ref []
  
+ let mark_loops ty = mark_loops_rec !already_visited ty
+ 
  let reset_loop_marks () =
    visited_objects := []; aliased := []
  
  let delayed = ref []
  
  let reset () =
!   reset_names (); reset_loop_marks (); delayed := []; already_visited := []
  
  let rec print_sep_list pr sep = function
      [] -> ()
***************
*** 702,709 ****
  
    reset ();
    aliased := params @ !aliased;
-   prepare_class_type cl.cty_type;
    let sty = referent_type (self_type cl.cty_type) in
    List.iter mark_loops cl.cty_params;
  
    List.iter check_name_of_type params;
--- 704,712 ----
  
    reset ();
    aliased := params @ !aliased;
    let sty = referent_type (self_type cl.cty_type) in
+   already_visited := [sty];
+   prepare_class_type cl.cty_type;
    List.iter mark_loops cl.cty_params;
  
    List.iter check_name_of_type params;
***************
*** 853,865 ****
  let rec type_expansion t t' =
    match t'.desc with
      Tvariant({var_name=Some _} as var) ->
!       type_expansion t
!         (newgenty(Tvariant
! 		  { var_closed = var.var_closed;
! 		    var_max = var.var_max;
! 		    var_min = var.var_min;
! 		    var_ext = var.var_ext;
! 		    var_name = None }))
    | _ ->
        if t == t' then type_expr t else begin
  	open_box 2;
--- 856,862 ----
  let rec type_expansion t t' =
    match t'.desc with
      Tvariant({var_name=Some _} as var) ->
!       type_expansion t (newgenty(Tvariant {var with var_name = None}))
    | _ ->
        if t == t' then type_expr t else begin
  	open_box 2;
Index: typing/typeclass.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typeclass.ml,v
retrieving revision 1.32
retrieving revision 1.37
diff -c -r1.32 -r1.37
*** typeclass.ml	1999/02/24 13:47:52	1.32
--- typeclass.ml	1999/06/11 01:46:36	1.37
***************
*** 216,222 ****
    vars := Vars.add lab (id, mut, ty) !vars;
    result
  
- 
  let inheritance impl self_type env concr_meths loc parent =
    match scrape_class_type parent with
      Tcty_signature cl_sig ->
--- 216,221 ----
***************
*** 251,259 ****
       Ctype.filter_self_method val_env lab priv meths self_type
    in
    let ty = transl_simple_type val_env false sty in
!   begin try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
      raise(Error(loc, Method_type_mismatch (lab, trace)))
-   end
  
  let declare_method val_env meths self_type lab priv sty loc =
    let (_, ty') =
--- 250,257 ----
       Ctype.filter_self_method val_env lab priv meths self_type
    in
    let ty = transl_simple_type val_env false sty in
!   try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
      raise(Error(loc, Method_type_mismatch (lab, trace)))
  
  let declare_method val_env meths self_type lab priv sty loc =
    let (_, ty') =
***************
*** 326,331 ****
--- 324,332 ----
  
  and class_signature env sty sign =
    let meths = ref Meths.empty in
+   (* One more level by symmetry with class declarations *)
+   Ctype.begin_def ();
+   Ctype.increase_global_level (); (* correct since no new outer variables *)
    let self_type = transl_simple_type env false sty in
    
    (* Check that the binder is a correct type, and introduce a dummy
***************
*** 345,350 ****
--- 346,355 ----
        sign
    in
    
+   (* Back to outer level *)
+   Ctype.end_def ();
+   Ctype.restore_global_level ();
+   
    {cty_self = self_type;
     cty_vars = val_sig;
     cty_concr = concr_meths }
***************
*** 390,399 ****
      (val_env, met_env, par_env, fields, concr_meths, inh_vals) =
    function
      Pcf_inher (sparent, super) ->
!       let parent = class_expr cl_num val_env par_env sparent in
        let (cl_sig, concr_meths) =
          inheritance true self_type val_env concr_meths sparent.pcl_loc
! 	  parent.cl_type
        in
        (* Variables *)
        let (val_env, met_env, par_env, inh_vars, inh_vals) =
--- 395,405 ----
      (val_env, met_env, par_env, fields, concr_meths, inh_vals) =
    function
      Pcf_inher (sparent, super) ->
!       let parent = class_expr cl_num val_env par_env
! 	  {sparent with pcl_desc = Pcl_apply (sparent, [])} in
        let (cl_sig, concr_meths) =
          inheritance true self_type val_env concr_meths sparent.pcl_loc
!           parent.cl_type
        in
        (* Variables *)
        let (val_env, met_env, par_env, inh_vars, inh_vals) =
***************
*** 436,444 ****
        Ctype.begin_def ();
        let exp = type_exp val_env sexp in
        Ctype.end_def ();
!       (* no need to try since !nongen_level == !current_level *)
!       Ctype.make_nongen exp.exp_type;
!       Ctype.generalize exp.exp_type;
        let (id, val_env, met_env, par_env) =
          enter_val cl_num vars lab mut exp.exp_type val_env met_env par_env
        in
--- 442,448 ----
        Ctype.begin_def ();
        let exp = type_exp val_env sexp in
        Ctype.end_def ();
!       Ctype.generalize_expansive exp.exp_type;
        let (id, val_env, met_env, par_env) =
          enter_val cl_num vars lab mut exp.exp_type val_env met_env par_env
        in
***************
*** 545,551 ****
  
    (* Self binder *)
    let (pat, meths, vars, val_env, meth_env, par_env) =
!       type_self_pattern cl_num val_env met_env par_env spat in
    let self_type = pat.pat_type in
  
    (* Check that the binder has a correct type, and introduce a dummy
--- 549,556 ----
  
    (* Self binder *)
    let (pat, meths, vars, val_env, meth_env, par_env) =
!     type_self_pattern cl_num val_env met_env par_env spat
!   in
    let self_type = pat.pat_type in
  
    (* Check that the binder has a correct type, and introduce a dummy
***************
*** 630,636 ****
  	     (Tconstr(Predef.path_option,[Ctype.newvar()],ref Mnil)));
        Ctype.end_def ();
        iter_pattern
! 	(fun {pat_type=ty} -> Ctype.make_nongen ty; Ctype.generalize ty)
  	pat;
        let pv =
          List.map
--- 635,641 ----
  	     (Tconstr(Predef.path_option,[Ctype.newvar()],ref Mnil)));
        Ctype.end_def ();
        iter_pattern
! 	(fun {pat_type=ty} -> Ctype.generalize_expansive ty)
  	pat;
        let pv =
          List.map
***************
*** 728,734 ****
                raise(Error(cl.cl_loc, Cannot_apply cl.cl_type))
  	    else ([], ty_fun)
        in
!       let (args, cty) = type_args false sargs cl.cl_type in
        {cl_desc = Tclass_apply (cl, args);
         cl_loc = scl.pcl_loc;
         cl_type = cty}
--- 733,739 ----
                raise(Error(cl.cl_loc, Cannot_apply cl.cl_type))
  	    else ([], ty_fun)
        in
!       let (args, cty) = type_args (sargs=[]) sargs cl.cl_type in
        {cl_desc = Tclass_apply (cl, args);
         cl_loc = scl.pcl_loc;
         cl_type = cty}
***************
*** 853,858 ****
--- 858,864 ----
       constr_type, dummy_class)
      (res, env) =
  
+   Ctype.begin_class_def ();  (* quick hack to make difference with env >= 2 *)
    reset_type_variables ();
    Ctype.begin_class_def ();
    
***************
*** 868,873 ****
--- 874,880 ----
    let (expr, typ) = kind env cl.pci_expr in
    
    Ctype.end_def ();
+   Ctype.end_def ();
    
    let sty = Ctype.self_type typ in
  
***************
*** 1060,1066 ****
        cls
    in
    Ctype.init_def (Ident.current_time ());
!   Ctype.begin_class_def ();
    let (res, env) =
      List.fold_left (initial_env define_class) ([], env) cls
    in
--- 1067,1073 ----
        cls
    in
    Ctype.init_def (Ident.current_time ());
!   Ctype.begin_def ();
    let (res, env) =
      List.fold_left (initial_env define_class) ([], env) cls
    in
***************
*** 1084,1090 ****
    (expr, expr)
  
  let class_declarations env cls =
!   type_classes true  class_declaration env cls
  
  let class_descriptions env cls =
    type_classes true class_description env cls
--- 1091,1097 ----
    (expr, expr)
  
  let class_declarations env cls =
!   type_classes true class_declaration env cls
  
  let class_descriptions env cls =
    type_classes true class_description env cls
Index: typing/typecore.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typecore.ml,v
retrieving revision 1.36
retrieving revision 1.39
diff -c -r1.36 -r1.39
*** typecore.ml	1999/03/08 07:49:11	1.36
--- typecore.ml	1999/06/22 06:18:27	1.39
***************
*** 475,484 ****
      [] -> false
    | (y,v) :: l -> no_opt x = no_opt y or mem_assoc x l
  
- type 'a clazy = Val of 'a | Lazy of (unit -> 'a)
- 
- let force = function Val x -> x | Lazy f -> f ()
- 
  let rec type_exp env sexp =
    match sexp.pexp_desc with
      Pexp_ident lid ->
--- 475,480 ----
***************
*** 599,643 ****
  	       var_max = [tag, ty] });
        	   exp_env = env }
    | Pexp_record(lid_sexp_list, opt_sexp) ->
!       let ty = newvar() in
!       let num_fields = ref 0 in
!       let type_label_exp (lid, sarg) =
!         let label =
!           try
!             Env.lookup_label lid env
!           with Not_found ->
!             raise(Error(sexp.pexp_loc, Unbound_label lid)) in
!         let (ty_arg, ty_res) = instance_label env label in
!         begin try
!           free_unify env ty_res ty
!         with Unify trace ->
!           raise(Error(sexp.pexp_loc, Label_mismatch(lid, trace)))
!         end;
!         let arg = type_expect env sarg ty_arg in
!         num_fields := Array.length label.lbl_all;
!         (label, arg) in
!       let lbl_exp_list = List.map type_label_exp lid_sexp_list in
!       let rec check_duplicates = function
!         [] -> ()
!       | (lid, sarg) :: remainder ->
!           if List.mem_assoc lid remainder
!           then raise(Error(sexp.pexp_loc, Label_multiply_defined lid))
!           else check_duplicates remainder in
!       check_duplicates lid_sexp_list;
!       let opt_exp =
!         match opt_sexp with
!           None -> None
!         | Some sexp -> Some(type_expect env sexp ty) in
!       if opt_sexp = None && List.length lid_sexp_list <> !num_fields then
!         raise(Error(sexp.pexp_loc, Label_missing));
!       { exp_desc = Texp_record(lbl_exp_list, opt_exp);
!         exp_loc = sexp.pexp_loc;
!         exp_type = ty;
!         exp_env = env }
    | Pexp_field(sarg, lid) ->
        let arg = type_exp env sarg in
        let label =
!         try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sexp.pexp_loc, Unbound_label lid)) in
--- 595,613 ----
  	       var_max = [tag, ty] });
        	   exp_env = env }
    | Pexp_record(lid_sexp_list, opt_sexp) ->
!       type_record env sexp.pexp_loc lid_sexp_list opt_sexp (newvar())
    | Pexp_field(sarg, lid) ->
        let arg = type_exp env sarg in
        let label =
! 	try match lid with Longident.Lident name ->
! 	  let ty = expand_head env arg.exp_type in
! 	  begin match ty.desc with Tconstr (path, _, _) ->
! 	    let decl = Env.find_type path env in
! 	    List.assoc name (Env.labels_of_type path decl)
! 	  | _ -> raise Not_found
! 	  end
! 	| _ -> raise Not_found
!         with Not_found -> try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sexp.pexp_loc, Unbound_label lid)) in
***************
*** 650,656 ****
    | Pexp_setfield(srecord, lid, snewval) ->
        let record = type_exp env srecord in
        let label =
!         try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sexp.pexp_loc, Unbound_label lid)) in
--- 620,634 ----
    | Pexp_setfield(srecord, lid, snewval) ->
        let record = type_exp env srecord in
        let label =
! 	try match lid with Longident.Lident name ->
! 	  let ty = expand_head env record.exp_type in
! 	  begin match ty.desc with Tconstr (path, _, _) ->
! 	    let decl = Env.find_type path env in
! 	    List.assoc name (Env.labels_of_type path decl)
! 	  | _ -> raise Not_found
! 	  end
! 	| _ -> raise Not_found
!         with Not_found -> try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sexp.pexp_loc, Unbound_label lid)) in
***************
*** 722,729 ****
  	    begin_def ();
              let ty = Typetexp.transl_simple_type env false sty in
  	    end_def ();
! 	    make_nongen ty;
! 	    generalize ty;
  	    let ty1 = instance ty and ty2 = instance ty in
              (type_expect env sarg ty1, ty2)
  	| (None, Some {ptyp_desc = Ptyp_variant var; ptyp_loc = loc})
--- 700,706 ----
  	    begin_def ();
              let ty = Typetexp.transl_simple_type env false sty in
  	    end_def ();
! 	    generalize_expansive ty;
  	    let ty1 = instance ty and ty2 = instance ty in
              (type_expect env sarg ty1, ty2)
  	| (None, Some {ptyp_desc = Ptyp_variant var; ptyp_loc = loc})
***************
*** 977,982 ****
--- 954,961 ----
          exp_loc = sexp.pexp_loc;
          exp_type = body.exp_type;
          exp_env = env }
+   | Pexp_record(lid_sexp_list, opt_sexp) ->
+       type_record env sexp.pexp_loc lid_sexp_list opt_sexp ty_expected
    | Pexp_sequence(sexp1, sexp2) ->
        let exp1 = type_statement env sexp1 in
        let exp2 = type_expect_opt del env sexp2 ty_expected in
***************
*** 1052,1062 ****
  (* Typing of an application *)
  
  and type_application env funct sargs =
!   let type_arg del sarg ty =
!     let clazy () = type_expect_opt del env sarg ty in
!     match sarg.pexp_desc with Pexp_function _ -> Lazy clazy
!     | _ -> match (repr ty).desc with Tarrow _ -> Lazy clazy
!     | _ -> Val (clazy ()) in
    let rec type_args ty_fun = function
      [] ->
        ([], ty_fun)
--- 1031,1037 ----
  (* Typing of an application *)
  
  and type_application env funct sargs =
!   let type_arg del sarg ty = lazy (type_expect_opt del env sarg ty) in
    let rec type_args ty_fun = function
      [] ->
        ([], ty_fun)
***************
*** 1091,1097 ****
        	      type_expect_opt true env sarg t1
  	  | _ -> fatal_error "Typecore.type_application" in
         	let argl, ty_res = solve_opt all_applied sargl' ty_parl ty_ret in
!       	(p1, Val
        	 { exp_desc = Texp_construct (Env.lookup_constructor
          	     	       (Longident.Lident "Some") Env.initial, [arg]);
    	   exp_loc = sarg.pexp_loc;
--- 1066,1072 ----
        	      type_expect_opt true env sarg t1
  	  | _ -> fatal_error "Typecore.type_application" in
         	let argl, ty_res = solve_opt all_applied sargl' ty_parl ty_ret in
!       	(p1, lazy
        	 { exp_desc = Texp_construct (Env.lookup_constructor
          	     	       (Longident.Lident "Some") Env.initial, [arg]);
    	   exp_loc = sarg.pexp_loc;
***************
*** 1100,1106 ****
        	:: argl, ty_res
      else if is_opt p1 & all_applied then
        let argl, ty_res = solve_opt true sargl ty_parl ty_ret in
!       (p1, Val
        	{ exp_desc = Texp_construct (Env.lookup_constructor
          	       	       	(Longident.Lident "None") Env.initial, []);
    	  exp_loc = Location.none;
--- 1075,1081 ----
        	:: argl, ty_res
      else if is_opt p1 & all_applied then
        let argl, ty_res = solve_opt true sargl ty_parl ty_ret in
!       (p1, lazy
        	{ exp_desc = Texp_construct (Env.lookup_constructor
          	       	       	(Longident.Lident "None") Env.initial, []);
    	  exp_loc = Location.none;
***************
*** 1116,1124 ****
        sargs = [] or List.exists (fun (p,_) -> not (is_opt p)) sargs
      and ty_parl, ty_ret = all_args funct.exp_type
      in solve_opt all_applied sargs ty_parl ty_ret in
!   let args = List.map (fun (p, clazy) -> p, force clazy) args in
    args, ty_res
  
  (* Typing of message sending *)
  
  and type_send env loc e met =
--- 1091,1169 ----
        sargs = [] or List.exists (fun (p,_) -> not (is_opt p)) sargs
      and ty_parl, ty_ret = all_args funct.exp_type
      in solve_opt all_applied sargs ty_parl ty_ret in
!   let _ =
!     List.fold_left
!       (fun args (p,_) ->
! 	let (clazy, args) = extract_assoc p args in
! 	ignore (Lazy.force clazy);
! 	args)
!       args sargs
!   in
!   let args = List.map (fun (p, clazy) -> p, Lazy.force clazy) args in
    args, ty_res
  
+ (* Typing of record expression *)
+ 
+ and type_record env loc lid_sexp_list opt_sexp ty = 
+   let full_ty = expand_head env ty in
+   let opt_exp =
+     match opt_sexp with
+       None -> None
+     | Some sexp -> Some(type_expect env sexp ty) in
+   let (lid,_) = List.hd lid_sexp_list in
+   let labels, num_fields =
+     try match lid with Longident.Lident name ->
+       let path =
+ 	match full_ty.desc with Tconstr (path, _, _) -> path
+ 	| _ ->
+ 	    match opt_exp with None -> raise Not_found
+ 	    | Some exp ->
+ 		match (expand_head env exp.exp_type).desc with
+ 		| Tconstr (path, _, _) -> path
+ 		| _ -> raise Not_found
+       in
+       let decl = Env.find_type path env in
+       let labels = Env.labels_of_type path decl in
+       if List.length labels = 0 then raise Not_found;
+       labels, List.length labels
+     | _ -> raise Not_found
+     with Not_found -> try
+       [], Array.length (Env.lookup_label lid env).lbl_all
+     with Not_found ->
+       raise(Error(loc, Unbound_label lid))
+   in
+   let type_label_exp (lid, sarg) =
+     let label =
+       try match lid with
+ 	Longident.Lident name when labels <> [] ->
+ 	  List.assoc name labels
+       |	_ ->
+           Env.lookup_label lid env
+       with Not_found ->
+         raise(Error(loc, Unbound_label lid)) in
+     let (ty_arg, ty_res) = instance_label env label in
+     begin try
+       unify env ty_res ty
+     with Unify trace ->
+       raise(Error(loc, Label_mismatch(lid, trace)))
+     end;
+     let arg = type_expect env sarg ty_arg in
+     (label, arg) in
+   let lbl_exp_list = List.map type_label_exp lid_sexp_list in
+   let rec check_duplicates = function
+       [] -> ()
+     | (lid, sarg) :: remainder ->
+         if List.mem_assoc lid remainder
+         then raise(Error(loc, Label_multiply_defined lid))
+         else check_duplicates remainder in
+   check_duplicates lid_sexp_list;
+   if opt_sexp = None && List.length lid_sexp_list <> num_fields then
+     raise(Error(loc, Label_missing));
+   { exp_desc = Texp_record(lbl_exp_list, opt_exp);
+     exp_loc = loc;
+     exp_type = ty;
+     exp_env = env }
+ 
  (* Typing of message sending *)
  
  and type_send env loc e met =
***************
*** 1171,1178 ****
             filter_method env met Public obj.exp_type)
      in
      end_def ();
!     if not (is_nonexpansive obj) then make_nongen typ;
!     generalize typ;
      let typ =
        match repr typ with
  	{desc = Tpoly (ty, [])} ->
--- 1216,1222 ----
             filter_method env met Public obj.exp_type)
      in
      end_def ();
!     if is_nonexpansive obj then generalize typ else generalize_expansive typ;
      let typ =
        match repr typ with
  	{desc = Tpoly (ty, [])} ->
***************
*** 1242,1248 ****
        let ty_arg = instance_sep env ty_arg in
        let (pat, ext_env) = type_pattern env spat in
        end_def ();
!       iter_pattern (fun {pat_type=ty} -> make_nongen ty; generalize ty) pat;
        unify_pat env
  	{ pat_desc = pat.pat_desc; pat_loc = pat.pat_loc;
  	  pat_type = instance_sep env pat.pat_type; pat_env = env }
--- 1286,1292 ----
        let ty_arg = instance_sep env ty_arg in
        let (pat, ext_env) = type_pattern env spat in
        end_def ();
!       iter_pattern (fun {pat_type=ty} -> generalize_expansive ty) pat;
        unify_pat env
  	{ pat_desc = pat.pat_desc; pat_loc = pat.pat_loc;
  	  pat_type = instance_sep env pat.pat_type; pat_env = env }
***************
*** 1271,1277 ****
    List.iter
      (fun pat ->
        iter_pattern
! 	(fun pat -> make_nongen pat.pat_type; generalize pat.pat_type)
  	pat)
      pat_list;
    let pat_list =
--- 1315,1321 ----
    List.iter
      (fun pat ->
        iter_pattern
! 	(fun pat -> generalize_expansive pat.pat_type)
  	pat)
      pat_list;
    let pat_list =
***************
*** 1290,1296 ****
    List.iter2
      (fun pat exp ->
         if not (is_nonexpansive exp) then
!          iter_pattern (fun pat -> make_nongen pat.pat_type) pat)
      pat_list exp_list;
    List.iter
      (fun pat -> iter_pattern (fun pat -> generalize pat.pat_type) pat)
--- 1334,1340 ----
    List.iter2
      (fun pat exp ->
         if not (is_nonexpansive exp) then
!          iter_pattern (fun pat -> generalize_expansive pat.pat_type) pat)
      pat_list exp_list;
    List.iter
      (fun pat -> iter_pattern (fun pat -> generalize pat.pat_type) pat)
***************
*** 1311,1317 ****
    let exp = type_exp env sexp in
    end_def();
    if is_nonexpansive exp then generalize exp.exp_type
!   else make_nongen exp.exp_type;
    exp
  
  (* Error report *)
--- 1355,1361 ----
    let exp = type_exp env sexp in
    end_def();
    if is_nonexpansive exp then generalize exp.exp_type
!   else generalize_expansive exp.exp_type;
    exp
  
  (* Error report *)
Index: typing/typetexp.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typetexp.ml,v
retrieving revision 1.22
retrieving revision 1.27
diff -c -r1.22 -r1.27
*** typetexp.ml	1999/03/08 07:49:12	1.22
--- typetexp.ml	1999/06/11 01:46:37	1.27
***************
*** 46,51 ****
--- 46,52 ----
  let univars        = ref ([] : type_expr list)
  let pre_univars    = ref ([] : type_expr list)
  let saved_type_variables = ref ([] : (string, type_expr) Tbl.t list)
+ let saved_aliases = ref ([] : (string, type_expr) Tbl.t list)
  
  let used_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
  let bindings       = ref ([] : (Location.t * type_expr * type_expr) list)
***************
*** 54,70 ****
  let reset_type_variables () =
    reset_global_level ();
    type_variables := Tbl.empty;
!   saved_type_variables := []
  
  let narrow () =
    increase_global_level ();
!   saved_type_variables := !type_variables :: !saved_type_variables
  
  let widen () =
    restore_global_level ();
!   match !saved_type_variables with
!     tv :: rem -> type_variables := tv; saved_type_variables := rem
!   | []        -> assert false
  
  let enter_type_variable strict name =
    try
--- 55,76 ----
  let reset_type_variables () =
    reset_global_level ();
    type_variables := Tbl.empty;
!   saved_type_variables := [];
!   aliases := Tbl.empty;
!   saved_aliases := []
  
  let narrow () =
    increase_global_level ();
!   saved_type_variables := !type_variables :: !saved_type_variables;
!   saved_aliases := !aliases :: !saved_aliases
  
  let widen () =
    restore_global_level ();
!   match !saved_type_variables, !saved_aliases with
!     tv :: rem, al :: rem' ->
!       type_variables := tv; saved_type_variables := rem;
!       aliases := al; saved_aliases := rem'
!   | _ -> assert false
  
  let enter_type_variable strict name =
    try
***************
*** 107,114 ****
    | Ptyp_var name ->
        begin try
  	let ty0 = Tbl.find name !aliases in
! 	let ty =
! 	  if ty0.level <> Btype.generic_level then ty0 else instance ty0 in
  	try unify env (newvar()) (newty(Tpoly(ty,!univars))); ty
  	with Unify _ -> raise (Error(styp.ptyp_loc, Bad_alias name))
        with Not_found ->
--- 113,121 ----
    | Ptyp_var name ->
        begin try
  	let ty0 = Tbl.find name !aliases in
! 	let ty = (* ty0 may be a stub; only drop it if really changed *)
! 	  if (repr ty0).level < Btype.generic_level then ty0 else instance ty0
! 	in
  	try unify env (newvar()) (newty(Tpoly(ty,!univars))); ty
  	with Unify _ -> raise (Error(styp.ptyp_loc, Bad_alias name))
        with Not_found ->
***************
*** 223,229 ****
        List.iter2
          (fun (sty, ty) ty' ->
             try unify_var env ty' ty with Unify trace ->
!              raise (Error(sty.ptyp_loc, Type_mismatch trace)))
          (List.combine stl args) params;
        cstr
    | Ptyp_object fields ->
--- 230,236 ----
        List.iter2
          (fun (sty, ty) ty' ->
             try unify_var env ty' ty with Unify trace ->
!              raise (Error(sty.ptyp_loc, Type_mismatch (swap_list trace))))
          (List.combine stl args) params;
        cstr
    | Ptyp_object fields ->
***************
*** 298,306 ****
  		    else v }
  	  in newty (Tvariant var)
        |	Tobject (fi, nm) ->
! 	  begin match rowvar with None -> ()
  	  | Some v ->
- 	      let _, row = flatten_fields fi in
  	      if row.desc <> Tvar then
  		raise(Error(styp.ptyp_loc, No_row_variable "object "));
  	      unify_var env row v
--- 305,315 ----
  		    else v }
  	  in newty (Tvariant var)
        |	Tobject (fi, nm) ->
! 	  let _, row = flatten_fields fi in
! 	  begin match rowvar with None ->
! 	      if policy = Univars && row.desc = Tvar then
! 		unify_var env row (new_pre_univar ())
  	  | Some v ->
  	      if row.desc <> Tvar then
  		raise(Error(styp.ptyp_loc, No_row_variable "object "));
  	      unify_var env row v
***************
*** 318,325 ****
  	    begin_def ();
  	    let ty = transl_type env policy (Some tc) st in
  	    end_def ();
! 	    make_nongen ty;
! 	    generalize ty;
  	    tr.desc <- Tlink ty;
  	    Ctype.instance ty
  	| _ ->
--- 327,333 ----
  	    begin_def ();
  	    let ty = transl_type env policy (Some tc) st in
  	    end_def ();
! 	    generalize_expansive ty;
  	    tr.desc <- Tlink ty;
  	    Ctype.instance ty
  	| _ ->
***************
*** 334,341 ****
  	  let trace = swap_list trace in
            raise(Error(styp.ptyp_loc, Alias_type_mismatch trace))
          end;
! 	make_nongen ty;
! 	generalize ty;
          Ctype.instance ty
        end 
    | Ptyp_poly(st, vars) ->
--- 342,348 ----
  	  let trace = swap_list trace in
            raise(Error(styp.ptyp_loc, Alias_type_mismatch trace))
          end;
! 	generalize_expansive ty;
          Ctype.instance ty
        end 
    | Ptyp_poly(st, vars) ->
***************
*** 379,399 ****
  
  let transl_simple_type env fixed styp =
    univars := [];
!   aliases := Tbl.empty;
    let typ = transl_type env (if fixed then Fixed else Extensible) None styp in
!   aliases := Tbl.empty;
    typ
  
  let transl_simple_type_univars env styp =
    univars := [];
-   aliases := Tbl.empty;
    pre_univars := [];
    begin_def ();
    let typ = transl_type env Univars None styp in
    end_def ();
    generalize typ;
    let univars = List.map repr !pre_univars in
-   aliases := Tbl.empty;
    pre_univars := [];
    let univars =
      filter (fun v -> v.desc = Tvar && v.level = Btype.generic_level) univars in
--- 386,407 ----
  
  let transl_simple_type env fixed styp =
    univars := [];
!   let saved = !aliases in
    let typ = transl_type env (if fixed then Fixed else Extensible) None styp in
!   if fixed then aliases := saved;
!   univars := [];
    typ
  
  let transl_simple_type_univars env styp =
    univars := [];
    pre_univars := [];
+   let saved = !aliases in
    begin_def ();
    let typ = transl_type env Univars None styp in
    end_def ();
    generalize typ;
+   aliases := saved;
    let univars = List.map repr !pre_univars in
    pre_univars := [];
    let univars =
      filter (fun v -> v.desc = Tvar && v.level = Btype.generic_level) univars in
***************
*** 407,418 ****
  
  let transl_simple_type_delayed env styp =
    univars := [];
!   aliases := Tbl.empty;
    used_variables := Tbl.empty;
    bindings := [];
    let typ = transl_type env Delayed None styp in
    let b = !bindings in
!   aliases := Tbl.empty;
    used_variables := Tbl.empty;
    bindings := [];
    (typ,
--- 415,426 ----
  
  let transl_simple_type_delayed env styp =
    univars := [];
!   let saved = !aliases in
    used_variables := Tbl.empty;
    bindings := [];
    let typ = transl_type env Delayed None styp in
    let b = !bindings in
!   aliases := saved;
    used_variables := Tbl.empty;
    bindings := [];
    (typ,
Index: bytecomp/simplif.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/bytecomp/simplif.ml,v
retrieving revision 1.7
retrieving revision 1.9
diff -c -r1.7 -r1.9
*** simplif.ml	1998/12/11 03:31:07	1.7
--- simplif.ml	1999/04/14 02:30:54	1.9
***************
*** 97,111 ****
      Lvar y when Ident.same x y -> v
    | lam -> map_lambda (subst x v) lam
  
! let rec beta_reduce lam = match map_lambda beta_reduce lam with
!     Lapply (Lfunction (kind, par::pars, lam), arg::args) ->
!       let func = if pars = [] then lam else Lfunction (kind, pars, lam) in
!       let body = if args = [] then func else Lapply (func, args) in
!       if Translcore.is_value (Ident.name par = "#conv") arg
!       then beta_reduce (subst par arg body)
!       else Llet (Strict, par, arg, beta_reduce body)
!   | Lapply (Llet (kind, ident, lam, body), args) ->
!       Llet (kind, ident, lam, beta_reduce (Lapply (body, args)))
    | lam -> lam
  
  let rec last = function
--- 97,125 ----
      Lvar y when Ident.same x y -> v
    | lam -> map_lambda (subst x v) lam
  
! let rec scrape_events lam =
!   match lam with
!     Levent (lam, _) -> scrape_events lam
!   | _ -> lam
! 
! let rec beta_reduce lam =
!   match map_lambda beta_reduce lam with
!     Lapply (func, args) as lam ->
!       begin match scrape_events func, args with
! 	Lfunction (kind, par::pars, lam), arg::args ->
! 	  let func =
! 	    if pars = [] then match lam with
! 	      Levent (lam, {lev_kind = Lev_function}) -> lam
! 	    |  _ -> lam
! 	    else Lfunction (kind, pars, lam) in
! 	  let body = if args = [] then func else Lapply (func, args) in
! 	  if Translcore.is_value (Ident.name par = "#conv") arg
! 	  then beta_reduce (subst par arg body)
! 	  else Llet (Strict, par, arg, beta_reduce body)
!       | Llet (kind, ident, lam, body), args ->
! 	  Llet (kind, ident, lam, beta_reduce (Lapply (body, args)))
!       |	_ -> lam
!       end
    | lam -> lam
  
  let rec last = function
***************
*** 123,148 ****
      Llet (Strict, id, lam, Lvar id')
      when Ident.name id = "#conv" & Ident.same id id' ->
        eta_reduce lam
!   | Lfunction (kind, pars, Lapply (lam, args)) as lam1
!     when pars <> [] & args <> [] ->
!       let par = last pars and arg = last args in
!       if arg = Lvar par & Ident.name par = "#conv" then
!         let args = but_last args and pars = but_last pars in
!         let app = if args = [] then lam else Lapply (lam, args) in
!         eta_reduce (if pars = [] then app else Lfunction (kind, pars, app))
!       else lam1
    | lam -> lam
  
  let rec group lam =
    match map_lambda group lam with
!     Lfunction (Curried, par1, Lfunction (Curried, par2, body)) ->
!       Lfunction (Curried, par1 @ par2, body)
!   | Lapply (Lapply (body, arg1), arg2) ->
!       Lapply (body, arg1 @ arg2)
!   | Lapply (Lsend (body, self, arg1), arg2) ->
!       Lsend (body, self, arg1 @ arg2)
!   | Lapply (Levent (Lsend (body, self, arg1), _), arg2) ->
!       Lsend (body, self, arg1 @ arg2)
    | lam -> lam
  
  (* Elimination of useless Llet(Alias) bindings.
--- 137,169 ----
      Llet (Strict, id, lam, Lvar id')
      when Ident.name id = "#conv" & Ident.same id id' ->
        eta_reduce lam
!   | Lfunction (kind, pars, body) as lam1 when pars <> [] ->
!       begin match scrape_events body with
! 	Lapply (lam, args) when args <> [] ->
! 	  let par = last pars and arg = last args in
! 	  if arg = Lvar par & Ident.name par = "#conv" then
!             let args = but_last args and pars = but_last pars in
!             let app = if args = [] then lam else Lapply (lam, args) in
!             eta_reduce (if pars = [] then app else Lfunction (kind, pars, app))
! 	  else lam1
!       |	_ -> lam1
!       end
    | lam -> lam
  
  let rec group lam =
    match map_lambda group lam with
!     Lfunction (Curried, par1, body) as lam ->
!       begin match scrape_events body with
! 	Lfunction (Curried, par2, body) ->
! 	  Lfunction (Curried, par1 @ par2, body)
!       |	_ -> lam
!       end
!   | Lapply (body, arg2) as lam ->
!       begin match scrape_events body with
! 	Lapply (body, arg1) -> Lapply (body, arg1 @ arg2)
!       | Lsend (body, self, arg1) -> Lsend (body, self, arg1 @ arg2)
!       |	_ -> lam
!       end
    | lam -> lam
  
  (* Elimination of useless Llet(Alias) bindings.
