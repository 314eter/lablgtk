
		LablGTK : an interface to the GIMP Tool Kit


Needed:
	olabl-2.00
	gtk-1.0.x
	gmake (there is no standard for conditionals)

How to compile:

	Just type "make".
	If anything changed, type "make configure; make".

	On FreeBSD, you need to link with libxpg4.so for Japanese
	output.

	For comfortable use with LablBrowser you must apply the two
	patches and reinstall olabl and lablbrowser.

Contents:

	gdk.ml		low-level interface to the General Drawing Kit
	gtk.ml		low-level interface to the GIMP Tool Kit
	gtkThread.ml	main loop for threaded version
	gtkObj.ml	object-oriented interface to GTK

	lablgtk		normal toplevel
	lablgtk_t	threaded toplevel

	examples/*.ml	various examples

	olabl.diffs		patch to apply to olabl-2.00
	lablbrowser.diffs	patch to apply to labltk41-2.00

How to run the examples:

	./lablgtk examples/???.ml

  some examples (e.g. buttons.ml) may need to be run from the examples
  directory

	../lablgtk -I .. ???.ml

How to use the threaded toplevel:

	% ./lablgtk_t
	        Objective Caml version 2.00 with Kyoto labels and variants
	
	# let id = GtkThread.start ();;
	val id : Thread.t = <abstr>

  The GTK main loop is now running in a separate thread. Any command
  is immediately reflected by the system.
  Beware that you cannot switch threads within a callback, that is the
  only thread related command you may use in a callback is
  Thread.create. On the other hand, all newly created threads will be
  run directly by the caml main loop, so they can use all thread
  operations.

Structure of the (raw) Gtk module:

  This module is composed of one submodule for each class.
  Signals specific to a widget are in a Signals inner module.
  Also, you can use "set w param: value" in place of "set_param w value".
  The set function has a weak form of inheritance: it provides access
  to all parameters in superclasses.

Structure of the GtkObj module:

  The structure has been greatly simplified.
  You can now freely inherit and subtype between widget classes.

  Practically, each widget class is composed of:
  * a frame method, returning the Gtk widget used for packing, etc...
    Usually this is the widget itself.
  * a misc sub-object, giving access to miscellanous functionality of
    the basic gtkwidget class
  * many connect_??? methods, allowing one to connect all available signals
  * a connect_event sub-object, for event signals

  Use the new_??? functions to create widgets. They admit many
  optional arguments. The last of them, packing:, allows you to call a
  function on your newly created widget.

Note about unit as method argument:

  O'Caml introduces no distinction between methods having side-effects
  and methods simply returning a value. In practice, this is
  confusing, and awkward when used as callbacks. For this reason all
  methods having noticeable side-effects should take arguments, and
  unit if they have no argument.

Memory management:

  Important efforts have been dedicated to cooperate with Gtk's
  reference counting mechanism. As a result you should generally be
  able to use Gdk/Gtk data structures without caring about memory
  management. They will be freed when nobody points to them any more.
  This also means that you do not need to pay too much attention to
  whether a data structure is still alive or not. If it is not, you
  should get an error rather than a core dump.
  The case of Gtk objects deserves special care. Since they are
  interactive, we cannot just destroy them when they are no longer
  referenced. They have to be explicitely destroyed. If a widget was
  added to a container widget, it will automatically be destroyed when
  its last container is destroyed. For this reason you should only
  destroy toplevel widgets, and be careful about not loosing all
  references to a still unused widget.
				   
Bug reports:
	Jacques Garrigue
	garrigue@kurims.kyoto-u.ac.jp

$Id$