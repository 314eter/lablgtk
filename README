
		LablGTK : an interface to the GIMP Tool Kit


Needed:
	olabl-2.00
	gtk-1.0.x
	gmake (standard make may work with a twist)

How to compile:

	Just type "make".
	If anything changed, type "make configure; make".

Contents:

	gdk.ml		low-level interface to the General Drawing Kit
	gtk.ml		low-level interface to the GIMP Tool Kit
	gtkThread.ml	main loop for threaded version
	gtkObj.ml	object-oriented interface to GTK

	lablgtk		normal toplevel
	lablgtk_t	threaded toplevel

	examples/*.ml		various examples
	examples/*_obj.ml	examples based on GtkObj

How to run the examples:

	./lablgtk examples/???.ml

  some examples may need to be run from the examples directory

	../lablgtk -I .. ???.ml

How to use the threaded toplevel:

	% ./lablgtk_t
	        Objective Caml version 2.00 with Kyoto labels and variants
	
	# let id = Thread.create GtkThread.main ();;
	val id : Thread.t = <abstr>

  The GTK main loop is now running in a separate thread. Any command
  is immediately reflected by the system.
  Beware that you cannot switch threads within a callback, that is the
  only thread related command you may use in a callback is
  Thread.create. On the other hand, all newly created threads will be
  run directly by the caml main loop, so they can use all thread
  operations.

Structure of the Gtk module:

  This module is composed of one submodule for each class.
  Signals shall be connected through the Mywidget.Connect.??? functions.
  Also, you can use "set w param: value" in place of "set_param w value".
  There is a weak form of inheritance: signals in Connect and
  parameters in set are propagated to submodules, along with some
  functions.
  To avoid a blow-up in size, functions and signals in the Widget
  module are not propagated: use them directly.

Memory management:

  Important efforts have been dedicated to cooperate with Gtk's
  reference counting mechanism. As a result you should generally be
  able to use Gdk/Gtk data structures without caring about memory
  management. They will be freed when nobody points to them any more.
  This also means that you do not need to pay too much attention to
  wether a data structure is still alive or not. If it is not, you
  should get an error rather than a core dump.
  The case of Gtk objects deserves special care. Since they are
  interactive, we cannot just destroy them when they are no longer
  referenced. They have to be explicitely destroyed. If a widget was
  added to a container widget, it will automatically be destroyed when
  its last container is destroyed. For this reason you should only
  destroy toplevel widgets, and be careful about not loosing all
  references to a still unused widget.
				   
Bug reports:
	Jacques Garrigue
	garrigue@kurims.kyoto-u.ac.jp

$Id$