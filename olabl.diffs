Index: otherlibs/threads/scheduler.c
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/otherlibs/threads/scheduler.c,v
retrieving revision 1.1.1.6
retrieving revision 1.2
diff -c -r1.1.1.6 -r1.2
*** scheduler.c	1998/08/20 01:28:53	1.1.1.6
--- scheduler.c	1998/11/15 13:48:16	1.2
***************
*** 435,441 ****
    /* Don't do an error if we're not initialized yet
       (we can be called from thread-safe Pervasives before initialization),
       just return immediately. */
!   if (curr_thread == NULL) return RESUMED_WAKEUP;
    check_callback();
    Assign(curr_thread->readfds, Field(arg, 0));
    Assign(curr_thread->writefds, Field(arg, 1));
--- 435,442 ----
    /* Don't do an error if we're not initialized yet
       (we can be called from thread-safe Pervasives before initialization),
       just return immediately. */
!   /* Do the same thing for callbacks (Jacques Garrigue) */
!   if (curr_thread == NULL || callback_depth > 1) return RESUMED_WAKEUP;
    check_callback();
    Assign(curr_thread->readfds, Field(arg, 0));
    Assign(curr_thread->writefds, Field(arg, 1));
Index: parsing/parser.mly
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/parsing/parser.mly,v
retrieving revision 1.19
retrieving revision 1.21
diff -c -r1.19 -r1.21
*** parser.mly	1998/09/02 07:02:14	1.19
--- parser.mly	1998/12/07 09:53:05	1.21
***************
*** 580,601 ****
  class_type:
      class_signature
        { $1 }
!   | simple_core_type2 MINUSGREATER class_type
!       { mkcty(Pcty_fun("", $1, $3)) }
!   | core_type_tuple2 MINUSGREATER class_type
!       { mkcty(Pcty_fun("", mktyp(Ptyp_tuple(List.rev $1)), $3)) }
!   | LABEL simple_core_type MINUSGREATER class_type
!       { mkcty(Pcty_fun($1, $2, $4)) }
!   | LABEL core_type_tuple MINUSGREATER class_type
!       { mkcty(Pcty_fun($1, mktyp(Ptyp_tuple(List.rev $2)), $4)) }
!   | optional simple_core_type MINUSGREATER class_type
!       { mkcty(Pcty_fun($1, mktyp(Ptyp_constr(Lident "option", [$2])), $4)) }
!   | optional core_type_tuple MINUSGREATER class_type
!       { mkcty(Pcty_fun($1,
! 		       mktyp(Ptyp_constr(Lident "option",
! 					 [mktyp(Ptyp_tuple(List.rev $2))])),
! 		       $4)) }
  ;
  class_signature:
      LBRACKET core_type_comma_list RBRACKET clty_longident
        { mkcty(Pcty_constr ($4, $2)) }
--- 580,599 ----
  class_type:
      class_signature
        { $1 }
!   | class_type_arg MINUSGREATER class_type
!       { mkcty(Pcty_fun(fst $1, snd $1, $3)) }
  ;
+ class_type_arg:
+     simple_core_type2		{ "", $1 }
+   | core_type_tuple2		{ "", mktyp(Ptyp_tuple(List.rev $1)) }
+   | LABEL simple_core_type	{ $1, $2 }
+   | LABEL core_type_tuple	{ $1, mktyp(Ptyp_tuple(List.rev $2)) }
+   | optional simple_core_type
+       { $1, mktyp(Ptyp_constr(Lident "option", [$2])) }
+   | optional core_type_tuple
+       { $1,
+ 	mktyp(Ptyp_constr(Lident "option", [mktyp(Ptyp_tuple(List.rev $2))])) }
+ ;
  class_signature:
      LBRACKET core_type_comma_list RBRACKET clty_longident
        { mkcty(Pcty_constr ($4, $2)) }
***************
*** 1174,1189 ****
  ;
  
  simple_core_type:
!     simple_core_type2	{ $1 }
!   | core_variant_type	{ $1 }
!   | core_variant_type type_longident %prec prec_constr_appl
        { mktyp(Ptyp_constr($2, [$1])) }
!   | core_variant_type SHARP class_longident variant_min
        %prec prec_constr_appl
        { mktyp(Ptyp_class($3, [$1], $4)) }
  ;
! core_variant_type: core_variant	{ mktyp(Ptyp_variant $1) };
! simple_core_type2:
      QUOTE ident
        { mktyp(Ptyp_var $2) }
    | QUOTE ident core_variant
--- 1172,1186 ----
  ;
  
  simple_core_type:
!     simple_core_type1	{ $1 }
!   | core_variant	{ mktyp (Ptyp_variant $1) }
!   | simple_core_type type_longident %prec prec_constr_appl
        { mktyp(Ptyp_constr($2, [$1])) }
!   | simple_core_type SHARP class_longident variant_min
        %prec prec_constr_appl
        { mktyp(Ptyp_class($3, [$1], $4)) }
  ;
! simple_core_type1:
      QUOTE ident
        { mktyp(Ptyp_var $2) }
    | QUOTE ident core_variant
***************
*** 1192,1199 ****
        { mktyp(Ptyp_any) }
    | type_longident
        { mktyp(Ptyp_constr($1, [])) }
-   | simple_core_type2 type_longident %prec prec_constr_appl
-       { mktyp(Ptyp_constr($2, [$1])) }
    | LPAREN core_type_comma_list RPAREN type_longident
        %prec prec_constr_appl
        { mktyp(Ptyp_constr($4, List.rev $2)) }
--- 1189,1194 ----
***************
*** 1205,1216 ****
        { mktyp(Ptyp_object []) }
    | SHARP class_longident variant_min
        { mktyp(Ptyp_class($2, [], $3)) }
-   | simple_core_type2 SHARP class_longident variant_min
-       %prec prec_constr_appl
-       { mktyp(Ptyp_class($3, [$1], $4)) }
    | LPAREN core_type_comma_list RPAREN SHARP class_longident variant_min
        %prec prec_constr_appl
        { mktyp(Ptyp_class($5, List.rev $2, $6)) }
  ;
  
  variant_min:
--- 1200,1216 ----
        { mktyp(Ptyp_object []) }
    | SHARP class_longident variant_min
        { mktyp(Ptyp_class($2, [], $3)) }
    | LPAREN core_type_comma_list RPAREN SHARP class_longident variant_min
        %prec prec_constr_appl
        { mktyp(Ptyp_class($5, List.rev $2, $6)) }
+ ;
+ simple_core_type2:
+     simple_core_type1		{ $1 }
+   | simple_core_type2 type_longident %prec prec_constr_appl
+       { mktyp(Ptyp_constr($2, [$1])) }
+   | simple_core_type2 SHARP class_longident variant_min
+       %prec prec_constr_appl
+       { mktyp(Ptyp_class($3, [$1], $4)) }
  ;
  
  variant_min:
Index: typing/ctype.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/ctype.ml,v
retrieving revision 1.46
retrieving revision 1.47
diff -c -r1.46 -r1.47
*** ctype.ml	1998/09/01 09:30:20	1.46
--- ctype.ml	1998/10/20 16:59:36	1.47
***************
*** 533,539 ****
          end
      | Tfield(_, k, _, _) ->
          begin match field_kind_repr k with
!           Fvar _ (* {contents = None} *) -> raise (Unify [(ty, newvar2 level)])
          | _                              -> ()
          end;
          ty.level <- level;
--- 533,541 ----
          end
      | Tfield(_, k, _, _) ->
          begin match field_kind_repr k with
!           Fvar _ (* {contents = None} *) ->
! 	    (* hideous hack for Didier *)
! 	    if ty.level > level + 1 then raise (Unify [(ty, newvar2 level)])
          | _                              -> ()
          end;
          ty.level <- level;
Index: typing/printtyp.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/printtyp.ml,v
retrieving revision 1.27
retrieving revision 1.30
diff -c -r1.27 -r1.30
*** printtyp.ml	1998/09/01 09:30:21	1.27
--- printtyp.ml	1998/12/07 09:53:05	1.30
***************
*** 189,196 ****
  
  let delayed = ref []
  
  let reset () =
!   reset_names (); reset_loop_marks (); delayed := []
  
  let rec print_sep_list pr sep = function
      [] -> ()
--- 189,200 ----
  
  let delayed = ref []
  
+ let in_class_func = ref false
+ let enter_class_func () = in_class_func := true
+ let leave_class_func () = in_class_func := false
+ 
  let reset () =
!   reset_names (); reset_loop_marks (); delayed := []; in_class_func := false
  
  let rec print_sep_list pr sep = function
      [] -> ()
***************
*** 219,225 ****
        end
      then print_string "'_"
      else print_string "'";
!     print_string (name_of_type ty')
    with Not_found ->
      let alias =
        List.memq ty' !aliased &
--- 223,230 ----
        end
      then print_string "'_"
      else print_string "'";
!     print_string (name_of_type ty');
!     in_class_func := false
    with Not_found ->
      let alias =
        List.memq ty' !aliased &
***************
*** 229,234 ****
--- 234,240 ----
  	  then print_string "'"
  	  else print_string "'_";
  	  print_string(name_of_type ty');
+ 	  in_class_func := false;
  	  false
        |	Tunivar -> false
        |	_ -> true
***************
*** 239,244 ****
--- 245,251 ----
        else open_box 0
      end;
      let prio = if alias then 0 else prio0 in
+     if prio < 2 then in_class_func := false;
      begin match ty.desc with
        Tvar ->
          if (not sch) or ty.level = generic_level
***************
*** 272,279 ****
        	let static = static_variant var
   	and alias = List.memq ty' !aliased in
  	if not alias & sch & ty'.level <> generic_level & ty'.desc = Tvar
! 	then print_string "'_";
! 	open_box 1; print_string "[";
  	if static then
  	  vartyplist sch var.var_max
  	else begin
--- 279,288 ----
        	let static = static_variant var
   	and alias = List.memq ty' !aliased in
  	if not alias & sch & ty'.level <> generic_level & ty'.desc = Tvar
! 	then (in_class_func := false; print_string "'_");
! 	let was_class_func = !in_class_func in
! 	print_string (if was_class_func then "([" else "[");
! 	open_box 0;
  	if static then
  	  vartyplist sch var.var_max
  	else begin
***************
*** 296,302 ****
  	      with Not_found -> fatal_error "Printtyp.typexp"
  	    end
  	end;
! 	print_string "]";
  	close_box()
      | Tarrow(p, ty1, ty2) ->
          if prio >= 2 then begin open_box 1; print_string "(" end
--- 305,311 ----
  	      with Not_found -> fatal_error "Printtyp.typexp"
  	    end
  	end;
! 	print_string (if was_class_func then "])" else "]");
  	close_box()
      | Tarrow(p, ty1, ty2) ->
          if prio >= 2 then begin open_box 1; print_string "(" end
***************
*** 355,361 ****
      if alias then begin
        print_string " as ";
        begin match ty.desc with
! 	Tvariant ({var_name = Some _} as var) ->
  	  if sch & ty'.level <> generic_level & ty'.desc = Tvar
  	  then print_string "'_"
  	  else print_string "'";
--- 364,370 ----
      if alias then begin
        print_string " as ";
        begin match ty.desc with
! 	Tvariant _ ->
  	  if sch & ty'.level <> generic_level & ty'.desc = Tvar
  	  then print_string "'_"
  	  else print_string "'";
***************
*** 606,612 ****
      print_string lab;
      print_string " :";
      print_space ();
!     typexp sch 0 ty;
      close_box ()
    end
  
--- 615,621 ----
      print_string lab;
      print_string " :";
      print_space ();
!     typexp sch 0 (match (repr ty).desc with Tpoly (t, _) -> t | _ -> ty);
      close_box ()
    end
  
***************
*** 623,629 ****
        let rowvar = referent_type sty in
        visited_objects := rowvar :: !visited_objects;
        begin match sty.desc with
!         Tobject (fi, _) -> mark_loops fi
        | _               -> assert false
        end;
        Vars.iter (fun _ (_, ty) -> mark_loops ty) sign.cty_vars
--- 632,644 ----
        let rowvar = referent_type sty in
        visited_objects := rowvar :: !visited_objects;
        begin match sty.desc with
!         Tobject (fi, _) ->
! 	  let fields, rest = flatten_fields fi in
! 	  List.iter
! 	    (fun (_, kind, ty) -> if field_kind_repr kind = Fpresent then
! 	      mark_loops (match (repr ty).desc with Tpoly(t,_) -> t | _ -> ty))
! 	    fields;
! 	  mark_loops rest
        | _               -> assert false
        end;
        Vars.iter (fun _ (_, ty) -> mark_loops ty) sign.cty_vars
***************
*** 679,690 ****
        close_box()
    | Tcty_fun (l, ty, cty) ->
        open_box 0;
!       if l <> "" then print_string (if l = "?" then "?" else l^":");
        begin match (repr ty).desc with
        	Tconstr(c, [ty], _) when is_opt l & c = Predef.path_option ->
! 	  typexp sch 0 ty
!       | _ -> typexp sch 0 ty
        end;
        print_string " ->";
        print_space ();
        perform_class_type sch p params cty;
--- 694,710 ----
        close_box()
    | Tcty_fun (l, ty, cty) ->
        open_box 0;
!       enter_class_func ();
!       if l <> "" then begin
! 	leave_class_func ();
! 	print_string (if l = "?" then "?" else l^":")
!       end;
        begin match (repr ty).desc with
        	Tconstr(c, [ty], _) when is_opt l & c = Predef.path_option ->
! 	  typexp sch 2 ty
!       | _ -> typexp sch 2 ty
        end;
+       leave_class_func ();
        print_string " ->";
        print_space ();
        perform_class_type sch p params cty;
Index: typing/typeclass.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typeclass.ml,v
retrieving revision 1.25
retrieving revision 1.27
diff -c -r1.25 -r1.27
*** typeclass.ml	1998/09/02 07:02:15	1.25
--- typeclass.ml	1998/12/07 11:00:46	1.27
***************
*** 251,256 ****
--- 251,270 ----
    end;
    generalize_poly ty'
  
+ let declare_method val_env meths self_type lab priv sty loc =
+   let (_, ty') =
+      Ctype.filter_self_method val_env lab priv meths self_type
+   in
+   let ty =
+     match sty.ptyp_desc with
+       Ptyp_poly (sty,[]) -> transl_simple_type_univars val_env sty
+     | _                  -> transl_simple_type val_env false sty
+   in
+   begin try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
+     raise(Error(loc, Method_type_mismatch (lab, trace)))
+   end;
+   generalize_poly ty'
+ 
  let type_constraint val_env sty sty' loc =
    let ty  = transl_simple_type val_env false sty in
    let ty' = transl_simple_type val_env false sty' in
***************
*** 288,298 ****
        (Vars.add lab (mut, ty) val_sig, concr_meths)
  
    | Pctf_virt (lab, priv, sty, loc) ->
!       virtual_method env meths self_type lab priv sty loc;
        (val_sig, concr_meths)
  
    | Pctf_meth (lab, priv, sty, loc)  ->
!       virtual_method env meths self_type lab priv sty loc;
        (val_sig, Concr.add lab concr_meths)
  
    | Pctf_cstr (sty, sty', loc) ->
--- 302,312 ----
        (Vars.add lab (mut, ty) val_sig, concr_meths)
  
    | Pctf_virt (lab, priv, sty, loc) ->
!       declare_method env meths self_type lab priv sty loc;
        (val_sig, concr_meths)
  
    | Pctf_meth (lab, priv, sty, loc)  ->
!       declare_method env meths self_type lab priv sty loc;
        (val_sig, Concr.add lab concr_meths)
  
    | Pctf_cstr (sty, sty', loc) ->
***************
*** 569,580 ****
--- 583,600 ----
         cl_loc = scl.pcl_loc;
         cl_type = Tcty_signature ty}
    | Pcl_fun (l, spat, None, scl') ->
+       Ctype.raise_nongen_level ();
+       Ctype.begin_def ();
        let (pat, pv, val_env, met_env) =
          Typecore.type_class_arg_pattern val_env met_env spat
        in
        if Ctype.is_opt l then unify_pat val_env pat
  	  (Ctype.newty
  	     (Tconstr(Predef.path_option,[Ctype.newvar()],ref Mnil)));
+       Ctype.end_def ();
+       iter_pattern
+ 	(fun {pat_type=ty} -> Ctype.make_nongen ty; Ctype.generalize ty)
+ 	pat;
        let pv =
          List.map
            (function (id, id', ty) ->
***************
*** 590,601 ****
                 exp_loc = Location.none;
                 exp_type = Ctype.none;
                 exp_env = Env.empty }];
-       Ctype.raise_nongen_level ();
        let cl = class_expr val_env met_env scl' in
        Ctype.end_def ();
        {cl_desc = Tclass_fun (pat, pv, cl);
         cl_loc = scl.pcl_loc;
!        cl_type = Tcty_fun (l, pat.pat_type, cl.cl_type)}
    | Pcl_fun (l, spat, Some e, scl') ->
        let pos = spat.ppat_loc.Location.loc_start in
        let loc = {Location.loc_start = pos; Location.loc_end = pos} in
--- 610,620 ----
                 exp_loc = Location.none;
                 exp_type = Ctype.none;
                 exp_env = Env.empty }];
        let cl = class_expr val_env met_env scl' in
        Ctype.end_def ();
        {cl_desc = Tclass_fun (pat, pv, cl);
         cl_loc = scl.pcl_loc;
!        cl_type = Tcty_fun (l, Ctype.instance pat.pat_type, cl.cl_type)}
    | Pcl_fun (l, spat, Some e, scl') ->
        let pos = spat.ppat_loc.Location.loc_start in
        let loc = {Location.loc_start = pos; Location.loc_end = pos} in
Index: typing/typecore.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typecore.ml,v
retrieving revision 1.28
retrieving revision 1.31
diff -c -r1.28 -r1.31
*** typecore.ml	1998/09/02 07:02:17	1.28
--- typecore.ml	1998/12/07 11:00:47	1.31
***************
*** 866,872 ****
          exp_env = env }
  
    | Pexp_poly _ ->
!       fatal_error "Typecor.type_exp : Pexp_poly"
  
  (* Typing of an expression with an expected type.
     Some constructs are treated specially to provide better error messages. *)
--- 866,872 ----
          exp_env = env }
  
    | Pexp_poly _ ->
!       fatal_error "Typecore.type_exp : Pexp_poly"
  
  (* Typing of an expression with an expected type.
     Some constructs are treated specially to provide better error messages. *)
***************
*** 1201,1206 ****
--- 1201,1209 ----
        |	{desc = Tvar} as ty ->
  	  let ty' = newvar () in
  	  unify env (instance_sep env ty) (newty(Tpoly(ty',[])));
+           if not !Clflags.nolabels then
+ 	    Location.print_warning loc
+               ("this expression is not known to have a method " ^ met ^ ".");
  	  ty'
        | _ ->
  	  assert false
***************
*** 1269,1274 ****
--- 1272,1278 ----
  
  and type_let env rec_flag spat_sexp_list =
    begin_def();
+   begin_def();
    let (pat_list, new_env) =
      type_pattern_list env (List.map (fun (spat, sexp) -> spat) spat_sexp_list)
    in
***************
*** 1279,1284 ****
--- 1283,1300 ----
  	pat_list spat_sexp_list;
        new_env
    in
+   end_def();
+   List.iter
+     (fun pat ->
+       iter_pattern
+ 	(fun pat -> make_nongen pat.pat_type; generalize pat.pat_type)
+ 	pat)
+     pat_list;
+   let pat_list =
+     List.map
+       (fun pat -> {pat with pat_type = instance pat.pat_type})
+       pat_list
+   in
    let exp_list =
      List.map2
        (fun (spat, sexp) pat -> type_expect exp_env sexp pat.pat_type)
***************
*** 1358,1371 ****
          (function () ->
             print_string "but is here used with type")
    | Apply_non_function (expected, provided) ->
!       let string_of_llist l = String.concat " "
!       	(List.map (function "" -> "\"\"" | s -> s ^ ":") l) in
        if expected = [] then
          print_string "This expression is not a function, it cannot be applied"
!       else begin
        	print_string "This function expects arguments labeled ";
  	print_string (string_of_llist expected);
! 	print_space (); print_string "but is applied on label(s) ";
  	print_string (string_of_llist provided)
        end
    | Label_multiply_defined lid ->
--- 1374,1397 ----
          (function () ->
             print_string "but is here used with type")
    | Apply_non_function (expected, provided) ->
!       let string_of_llist l =
! 	String.concat " " (List.map (fun s -> "\"" ^ s ^ "\"") l) in
        if expected = [] then
          print_string "This expression is not a function, it cannot be applied"
!       else if List.length expected < List.length provided then
! 	print_string "This function has too many arguments"
!       else let provided = List.map no_opt provided
!       and expected = List.map no_opt expected in
!       let unexpected = filter (fun x -> not (List.mem x expected)) provided in
!       if unexpected <> [] then begin
! 	print_string "This function is applied on unexpected label";
! 	print_string (if List.length unexpected > 1 then "s " else " ");
! 	print_string (string_of_llist unexpected)
!       end else begin
        	print_string "This function expects arguments labeled ";
  	print_string (string_of_llist expected);
! 	print_space (); print_string "but is applied on label";
! 	print_string (if List.length provided > 1 then "s " else " ");
  	print_string (string_of_llist provided)
        end
    | Label_multiply_defined lid ->
Index: typing/typecore.mli
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typecore.mli,v
retrieving revision 1.9
retrieving revision 1.10
diff -c -r1.9 -r1.10
*** typecore.mli	1998/09/01 09:30:24	1.9
--- typecore.mli	1998/12/07 11:00:48	1.10
***************
*** 51,56 ****
--- 51,57 ----
  	Env.t -> Typedtree.expression -> type_expr -> unit
  val unify_pat:
  	Env.t -> Typedtree.pattern -> type_expr -> unit
+ val iter_pattern: (Typedtree.pattern -> unit) -> Typedtree.pattern -> unit
  
  type error =
      Unbound_value of Longident.t
Index: typing/typetexp.ml
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typetexp.ml,v
retrieving revision 1.18
retrieving revision 1.19
diff -c -r1.18 -r1.19
*** typetexp.ml	1998/08/20 10:13:12	1.18
--- typetexp.ml	1998/11/30 09:09:17	1.19
***************
*** 44,49 ****
--- 44,50 ----
  let type_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
  let aliases        = ref (Tbl.empty : (string, type_expr) Tbl.t)
  let univars        = ref ([] : type_expr list)
+ let pre_univars    = ref ([] : type_expr list)
  let saved_type_variables = ref ([] : (string, type_expr) Tbl.t list)
  
  let used_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
***************
*** 86,96 ****
      Tpoly _ -> ty
    | _ -> Ctype.newty (Tpoly (ty, []))
  
  let rec swap_list = function
      x :: y :: l -> y :: x :: swap_list l
    | l -> l
  
! type policy = Fixed | Extensible | Delayed
  
  let rec transl_type env policy rowvar styp =
    if rowvar <> None then begin match styp.ptyp_desc with
--- 87,100 ----
      Tpoly _ -> ty
    | _ -> Ctype.newty (Tpoly (ty, []))
  
+ let new_pre_univar () =
+   let v = newvar () in pre_univars := v :: !pre_univars; v
+ 
  let rec swap_list = function
      x :: y :: l -> y :: x :: swap_list l
    | l -> l
  
! type policy = Fixed | Extensible | Delayed | Univars
  
  let rec transl_type env policy rowvar styp =
    if rowvar <> None then begin match styp.ptyp_desc with
***************
*** 98,104 ****
    | _ -> raise(Error(styp.ptyp_loc, No_row_variable ""))
    end;
    match styp.ptyp_desc with
!     Ptyp_any -> new_global_var()
    | Ptyp_var name ->
        begin try
  	let ty0 = Tbl.find name !aliases in
--- 102,109 ----
    | _ -> raise(Error(styp.ptyp_loc, No_row_variable ""))
    end;
    match styp.ptyp_desc with
!     Ptyp_any ->
!       if policy = Univars then new_pre_univar () else new_global_var ()
    | Ptyp_var name ->
        begin try
  	let ty0 = Tbl.find name !aliases in
***************
*** 122,127 ****
--- 127,140 ----
                type_variables := Tbl.add name v !type_variables;
                v
              end
+         | Univars ->
+             begin try
+               Tbl.find name !type_variables
+             with Not_found ->
+ 	      let v = new_pre_univar () in
+ 	      aliases := Tbl.add name v !aliases;
+ 	      v
+             end
          | Delayed ->
              begin try
                Tbl.find name !used_variables
***************
*** 174,180 ****
  	  var_name = None;
  	  var_ext =
  	    match rowvar with
! 	      None -> if static then newty Tnil else new_global_var ()
  	    | Some v -> v }
        in
        newty (Tvariant var)
--- 187,196 ----
  	  var_name = None;
  	  var_ext =
  	    match rowvar with
! 	      None ->
! 		if static then newty Tnil else
! 		if policy = Univars then new_pre_univar ()
! 		else new_global_var ()
  	    | Some v -> v }
        in
        newty (Tvariant var)
***************
*** 261,267 ****
  	        match rowvar with
  		  None ->
  		    if both or List.length var.var_max = List.length var_min
! 		    then newty Tnil else newvar ()
  		| Some v ->
  		    if both then
  		      raise(Error(styp.ptyp_loc, No_row_variable "variant "))
--- 277,285 ----
  	        match rowvar with
  		  None ->
  		    if both or List.length var.var_max = List.length var_min
! 		    then newty Tnil
! 		    else if policy = Univars then new_pre_univar ()
! 		    else newvar ()
  		| Some v ->
  		    if both then
  		      raise(Error(styp.ptyp_loc, No_row_variable "variant "))
***************
*** 343,349 ****
  	None ->
  	  if policy = Fixed then
              raise(Error(field.pfield_loc, Unbound_type_variable ".."));
! 	  newvar ()
        |	Some v -> v
        end
    | {pfield_desc = Pfield(s, e)}::l ->
--- 361,367 ----
  	None ->
  	  if policy = Fixed then
              raise(Error(field.pfield_loc, Unbound_type_variable ".."));
! 	  if policy = Univars then new_pre_univar () else newvar ()
        |	Some v -> v
        end
    | {pfield_desc = Pfield(s, e)}::l ->
***************
*** 357,362 ****
--- 375,401 ----
    let typ = transl_type env (if fixed then Fixed else Extensible) None styp in
    aliases := Tbl.empty;
    typ
+ 
+ let transl_simple_type_univars env styp =
+   univars := [];
+   aliases := Tbl.empty;
+   pre_univars := [];
+   begin_def ();
+   let typ = transl_type env Univars None styp in
+   end_def ();
+   generalize typ;
+   let univars = List.map repr !pre_univars in
+   aliases := Tbl.empty;
+   pre_univars := [];
+   let univars =
+     filter (fun v -> v.desc = Tvar && v.level = Btype.generic_level) univars in
+   let univars =
+     List.fold_left
+       (fun acc v ->
+ 	if List.memq v acc then acc else (v.desc <- Tunivar ; v :: acc))
+       [] univars
+   in
+   instance (Btype.newgenty (Tpoly (typ, univars)))
  
  let transl_simple_type_delayed env styp =
    univars := [];
Index: typing/typetexp.mli
===================================================================
RCS file: /staff2/garrigue/repos/ocaml/typing/typetexp.mli,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -r1.7 -r1.8
*** typetexp.mli	1998/08/20 10:13:13	1.7
--- typetexp.mli	1998/11/30 09:09:18	1.8
***************
*** 15,20 ****
--- 15,22 ----
  
  val transl_simple_type:
          Env.t -> bool -> Parsetree.core_type -> Types.type_expr
+ val transl_simple_type_univars:
+         Env.t -> Parsetree.core_type -> Types.type_expr
  val transl_simple_type_delayed:
          Env.t -> Parsetree.core_type -> Types.type_expr * (unit -> unit)
          (* Translate a type, but leave type variables unbound. Returns
